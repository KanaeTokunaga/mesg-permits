---
title: "Grouped Licenses Network Analysis"
subtitle: "Based on Stoll et al. 2016 license categories"
author: "cslovas"
format: 
  html:
    toc: true
    self-contained: true
editor: visual
---

```{r, message = FALSE}
#| label: load packages & data
#| echo: false
#| warning: false
library(tidyverse)
library(janitor)
library(tidygraph)
library(ggraph)
library(igraph)
library(patchwork)
library(gmRi)
library(grid)
library(here)
library(gt)

# Read in gomfish package from Joshua and Theresa
devtools::install_github("Social-Oceans-Lab/gomfish")
library(gomfish)

data(ind_lic_portfolio) 

ind_lic_portfolio <- ind_lic_portfolio %>% filter(!license_year == "2022") # unreliable

# Read in updated license codes 
updated_license_codes <- read.csv(here("Data", "updated_license_codes.csv")) %>%
  rename("license_type" = "code")

# Add Stoll et al 2016 license subdivisions
license_divisions <- read.csv(here("Data", "stoll_license_divisions.csv")) %>%
  select(License.Type, Target.Species, Stoll.et.al..2016.Name) %>%
  rename("description" = "License.Type",
         "group" = "Target.Species",
         "license_group" = "Stoll.et.al..2016.Name")
```

```{r}
#| label: license types
#| echo: false
#| message: false
#| warning: false
#| column: page

# Remove indigenous and non-harvester licenses
license_types <- names(ind_lic_portfolio %>%
                         select(!c(landings_number, license_year)))
license_types <- as_tibble(license_types) %>%
  rename("license_type" = "value") %>%
  left_join(updated_license_codes) %>%
  mutate(description = str_to_sentence(description))

license_types %>%
  filter(!group %in% c("Demo","Post-Harvest", "Non-resident", "Recreational")) %>%
  filter(!(str_starts(license_type, "ma"))) %>%
  filter(!(str_starts(license_type, "mi"))) %>%
  filter(!(str_starts(license_type, "nb"))) %>%
  filter(!(str_starts(license_type, "p")))  %>%
  filter(!license_type %in% c("st", "sts", "csw", "csws", "fhc", "lnc", "mws", "mw", "ncs", "nfhc", "nfhs", "vh")) %>%
  drop_na() -> license_types # the one NA here is sut 

license_types %>% 
  full_join(license_divisions) -> license_types

license_types %>% 
  gt() %>% 
  cols_hide(license_type) %>%
  cols_label(
    description    = md("**License Type**"),
    license_group  = md("**Stoll 2016 Grouping**"),
    group          = md("**Target Species**")) # add widget here to select target species and spit out license and grouping
```

## Portfolio by License Subdivisions

Using Theresa Burnham's code for building the individual license portfolio, license types were grouped license divisions as described in Stoll et al. 2016. A binary matrix was created, whereas 1 denotes an individual license holding for a corresponding year and 0 denotes no license held. With this co-occurrence matrix, we can quantify which license types were held together over the past 30 years and how those holdings have changed.

```{r, message=FALSE}
#| label: license portfolio
#| echo: false
#| message: false

ind_lic_portfolio %>%
  select(license_year,landings_number, license_types$license_type) %>%
  pivot_longer(cols = 3:51, names_to = "license_type", values_to = "licensed") %>%
  filter(!licensed == 0) %>%
  left_join(license_types) %>%
  mutate(row = row_number()) %>%
  select(license_year, landings_number, licensed, license_group, row) %>%
  pivot_wider(names_from=license_group,values_from=licensed,names_expand=TRUE,values_fill = list(licensed=0)) %>%
  select(-row)%>%
  group_by(landings_number,license_year)%>%
  summarise(across(everything(),sum))-> species_portfolio

```

```{r}
#| label:   unique license types each year 
#| echo:    false
#| message: false
#| warning: false
#| column:  page
#| fig-width:  8
#| fig-height: 6
#| fig-align: center

species_portfolio %>%
  ungroup() %>%
  select(!landings_number) %>%
  pivot_longer(cols = 2:28, names_to = "license_group", values_to = "count") %>%
  filter(!count == 0) %>% 
  select(license_year, license_group) %>% 
  distinct() %>%
  group_by(license_year) %>%
  nest() %>% 
  arrange(license_year) %>%
  mutate(unique_license_groups = map_dbl(data, function(x){nrow(x)})) %>%
  rename("license_groups" = "data")-> unique_license_groups
```


## Annual Species Metrics

### Degree centrality

"The *degree* of a node is the number of other nodes that single node is connected to.

Important nodes tend to have more connections to other nodes. Highly connected nodes are interpreted to have high degree centrality."

```{r}
#| label:      annual metrics
#| echo:       false
#| message:    false
#| warning:    false
#| column:     page
#| fig-width:  9
#| fig-height: 13
#| fig-align: center

annual_co_matrix <- species_portfolio %>%
  arrange(license_year) %>%
  # filter(!is.na(landings_number)) %>%
  ungroup(landings_number) %>%
  select(!landings_number) %>%
  group_by(license_year)%>%
  nest() %>% 
  left_join(unique_license_groups) %>%
  select(license_year, data, license_groups) %>% 
  mutate(co_matrix = map2(data, license_groups, function(x, y){
    df <- x %>% select(y$license_group) # this filters the portfolio to feature only species harvested in that year. If you want to run with all species, command out this line
    out <- crossprod(as.matrix(df)) 
    diag(out) <- 0
    return(out)
  })) %>%
  select(license_year, co_matrix) 

annual_metrics <- annual_co_matrix %>%
  mutate(graph_obj     = map(co_matrix, function(x){graph.adjacency(x, mode = "undirected", weighted = TRUE)}),
         degree        = map(graph_obj, function(x){degree(x)}),
         betweeness    = map(graph_obj, function(x){betweenness(x)}),
         density       = map_dbl(graph_obj, function(x){edge_density(x, loops = FALSE)}),
         community     = map(graph_obj, function(x){cluster_louvain(x)}),
         modularity    = map_dbl(community, function(x){modularity(x)}),
         membership    = map(community, function(x){membership(x)}),
         evcent        = map(graph_obj, function(x){evcent(x)})) %>%
  arrange(license_year)

metrics_series <- annual_metrics %>% 
  select(license_year, degree) %>% 
  unnest_longer(degree) %>% 
  group_by(degree_id) %>%
  rename("license_group" = "degree_id") %>%
  full_join(annual_metrics %>% 
              select(license_year, betweeness) %>% 
              unnest_longer(betweeness) %>% 
              group_by(betweeness_id) %>%
              rename("license_group" = "betweeness_id")) %>% 
  relocate("license_group", .after = "license_year") %>%
  nest() %>%
  arrange(license_group)

degree_plots <- metrics_series %>% 
  mutate(time_series = map2(data, license_group, function(x, license_group){
    out <- ggplot(data = x)+
      geom_line(aes(x=license_year, y=degree)) +
      ylim(c(0, 40)) + 
      xlim(c(1990, 2021)) +
      theme_gmri(plot.title = element_text(size = 8),
                 axis.text  = element_text(size = 6),
                 axis.title = element_blank(),
                 strip.text = element_text(size = 8, color = "black"),
                 strip.background = element_blank()) +
      ggtitle(license_group)
    return(out)
  })) 

gridExtra::marrangeGrob(degree_plots$time_series, layout_matrix = matrix(1:12, ncol = 3, nrow = 4, byrow= TRUE), top = NULL, left = textGrob(expression(bold("Degree")), rot = 90, gp = gpar(col = "black", fontsize = 8)))
```
### Betweeness

"\[*Betweenness*\] ranks the nodes based on the flow of connections through the network. Importance is demonstrated through high frequency of connection with multiple other nodes. Nodes with high levels of betweenness tend to serve as a bridge for multiple sets of other important nodes." [*Source*](https://bookdown.org/jdholster1/idsr/network-analysis.html#advanced-case-study)

```{r}
#| label:      betweeness
#| echo:       false
#| warning:    false
#| column:     page
#| fig-width:  9
#| fig-height: 13
#| fig-align: center

betweeness_plots <- metrics_series %>% 
  mutate(time_series = map2(data, license_group, function(x, license_group){
    out <- ggplot(data = x)+
      geom_line(aes(x=license_year, y= as.numeric(betweeness))) +
      # ylim(c(0, 40)) + 
      xlim(c(1990, 2021)) +
      theme_gmri(plot.title = element_text(size = 8),
                 axis.text  = element_text(size = 6),
                 axis.title = element_blank(),
                 strip.text = element_text(size = 8, color = "black"),
                 strip.background = element_blank()) +
      ggtitle(license_group)
    return(out)
  })) 

gridExtra::marrangeGrob(betweeness_plots$time_series, layout_matrix = matrix(1:15, ncol = 3, nrow = 5, byrow= TRUE), top = NULL, left = textGrob(
  expression(bold("Degree")), rot = 90, gp = gpar(col = "black", fontsize = 8)))
```

## Annual Network Plots

Density time series and network plots are available [here](https://carlylovas.github.io/mesg-permits/R/license_network_plots.html)

```{r}
#| label: network plots
#| echo: false
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 8
#| fig-align: center

annual_graphs <- annual_metrics %>%
  mutate(ggraph = map2(graph_obj, license_year, function(x, y){
    x <- as_tbl_graph(x)
    x %>% 
      activate(nodes) %>%
      mutate(community = as.character(group_louvain())) -> x
    out <- ggraph(x, 'kk') + 
      geom_node_point(aes(color = community), size = 7, alpha = 1, show.legend = FALSE) +
      geom_edge_link(aes(width = weight), alpha = 0.5, show.legend = FALSE) + 
      coord_fixed() +
      scale_edge_width(range = c(0.2, 2)) +
      # scale_color_discrete() +
      scale_color_gmri() +
      ggtitle(license_year) +
      geom_node_text(aes(label = name), repel = TRUE, color = "black", max.overlaps = 100) +
      theme_graph()   
  })) %>%
  mutate(ggraph_circular = map2(graph_obj, license_year, function(x, y){
    x <- as_tbl_graph(x)
    x %>% 
      activate(nodes) %>%
      mutate(community = as.character(group_louvain())) -> x
    out <- ggraph(x, layout = "linear", circular = TRUE) + 
      geom_node_point(aes(color = community), size = 7, alpha = 1, show.legend = FALSE) +
      geom_edge_link(aes(width = weight), alpha = 0.5, show.legend = FALSE) + 
      scale_edge_width(range = c(0.2, 2)) +
      scale_color_gmri() +
      coord_fixed() +
      ggtitle(license_year) +
      geom_node_text(aes(label = name), repel = TRUE, color = "black", max.overlaps = 100) +
      theme_graph() 
  })) %>%
  select(license_year, density, modularity, ggraph, ggraph_circular)

gridExtra::marrangeGrob(annual_graphs$ggraph, layout_matrix = matrix(1:2, ncol = 2, nrow = 1, byrow= TRUE), top = NULL)

```
